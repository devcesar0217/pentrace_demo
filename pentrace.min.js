/**
 * PenTrace Signature Pad Library
 * A comprehensive signature capture library for web applications
 *
 * Features:
 * - Touch and mouse support
 * - High DPI display support
 * - Multiple export formats (PNG, SVG, JSON)
 * - Signature validation
 * - Customizable appearance
 * - Responsive design
 *
 * @version 1.0.0
 * @author Cesar Tolentino
 */

(function (global) {
	"use strict";

	/**
	 * Custom Signature Pad Class
	 */
	class PenTrace {
		constructor(canvas, options = {}) {
			this.canvas = canvas;
			this.ctx = canvas.getContext("2d");
			this.options = this.mergeOptions(options);

			// State management
			this.isDrawing = false;
			this.points = [];
			this.lastPoint = null;
			this._isEmpty = true;

			// Performance optimization
			this.rafId = null;

			this.init();
		}

		/**
		 * Default options
		 */
		getDefaultOptions() {
			return {
				// Drawing settings
				minWidth: 0.5,
				maxWidth: 2.5,
				velocityFilterWeight: 0.7,
				smoothing: 1,

				// Colors
				penColor: "#000000",
				backgroundColor: "#ffffff",

				// Canvas settings
				dotSize: 0,
				throttle: 16,

				// Callbacks
				onBegin: null,
				onEnd: null,
				onSignatureChange: null,

				// Validation
				minPoints: 3,
				minDistance: 5,
			};
		}

		/**
		 * Merge user options with defaults
		 */
		mergeOptions(options) {
			const defaults = this.getDefaultOptions();
			const merged = {};

			for (const key in defaults) {
				if (defaults.hasOwnProperty(key)) {
					merged[key] = options.hasOwnProperty(key)
						? options[key]
						: defaults[key];
				}
			}

			return merged;
		}

		/**
		 * Initialize the signature pad
		 */
		init() {
			this.resizeCanvas();
			this.setupEventListeners();
			this.clear();

			// Handle window resize
			window.addEventListener(
				"resize",
				this.debounce(() => {
					this.resizeCanvas();
				}, 100)
			);
		}

		/**
		 * Update has-content class based on signature state
		 */
		updateHasContentClass() {
			const wrapper = this.canvas.closest(".pentrace-signature-pad-wrapper");
			if (!wrapper) return;
			if (this._isEmpty || this.points.length < this.options.minPoints) {
				wrapper.classList.remove("has-content");
			} else {
				wrapper.classList.add("has-content");
			}
		}

		/**
		 * Resize canvas for high DPI displays
		 */
		resizeCanvas() {
			const ratio = Math.max(window.devicePixelRatio || 1, 1);
			const rect = this.canvas.getBoundingClientRect();

			this.canvas.width = rect.width * ratio;
			this.canvas.height = rect.height * ratio;
			this.canvas.style.width = rect.width + "px";
			this.canvas.style.height = rect.height + "px";

			this.ctx.scale(ratio, ratio);

			// Redraw signature if it exists
			if (!this._isEmpty) {
				this.redraw();
			}
		}

		/**
		 * Setup event listeners
		 */
		setupEventListeners() {
			// Mouse events
			this.canvas.addEventListener("mousedown", this.handleStart.bind(this));
			this.canvas.addEventListener("mousemove", this.handleMove.bind(this));
			this.canvas.addEventListener("mouseup", this.handleEnd.bind(this));
			this.canvas.addEventListener("mouseout", this.handleEnd.bind(this));

			// Touch events
			this.canvas.addEventListener("touchstart", this.handleStart.bind(this));
			this.canvas.addEventListener("touchmove", this.handleMove.bind(this));
			this.canvas.addEventListener("touchend", this.handleEnd.bind(this));

			// Prevent scrolling on touch devices
			this.canvas.addEventListener("touchstart", (e) => {
				e.preventDefault();
			});
			this.canvas.addEventListener("touchmove", (e) => {
				e.preventDefault();
			});
		}

		/**
		 * Get point from event
		 */
		getPointFromEvent(event) {
			const rect = this.canvas.getBoundingClientRect();
			const point = {
				x: event.clientX - rect.left,
				y: event.clientY - rect.top,
				time: Date.now(),
			};

			return point;
		}

		/**
		 * Get touch point from event
		 */
		getTouchPointFromEvent(event) {
			const rect = this.canvas.getBoundingClientRect();
			const touch = event.touches[0];
			const point = {
				x: touch.clientX - rect.left,
				y: touch.clientY - rect.top,
				time: Date.now(),
			};

			return point;
		}

		/**
		 * Handle drawing start
		 */
		handleStart(event) {
			event.preventDefault();

			const point = event.type.includes("touch")
				? this.getTouchPointFromEvent(event)
				: this.getPointFromEvent(event);

			this.isDrawing = true;
			this.points = [point];
			this.lastPoint = point;
			this._isEmpty = false;

			if (this.options.onBegin) {
				this.options.onBegin();
			}

			this.drawDot(point);
		}

		/**
		 * Handle drawing move
		 */
		handleMove(event) {
			if (!this.isDrawing) return;

			event.preventDefault();

			const point = event.type.includes("touch")
				? this.getTouchPointFromEvent(event)
				: this.getPointFromEvent(event);

			this.points.push(point);

			// Throttle drawing for performance
			if (this.rafId) {
				cancelAnimationFrame(this.rafId);
			}

			this.rafId = requestAnimationFrame(() => {
				this.drawLine(this.lastPoint, point);
				this.lastPoint = point;
			});
		}

		/**
		 * Handle drawing end
		 */
		handleEnd(event) {
			if (!this.isDrawing) return;

			event.preventDefault();

			this.isDrawing = false;
			cancelAnimationFrame(this.rafId);

			if (this.options.onEnd) {
				this.options.onEnd();
			}

			if (this.options.onSignatureChange) {
				this.options.onSignatureChange();
			}

			if (this.points.length > 3) {
				this.ctx.save();
				this.ctx.strokeStyle = this.options.penColor;
				this.ctx.lineWidth = this.options.maxWidth;
				this.ctx.lineCap = "round";
				this.ctx.lineJoin = "round";
				this.ctx.beginPath();
				this.ctx.moveTo(this.points[0].x, this.points[0].y);

				for (let i = 1; i < this.points.length - 2; i++) {
					const xc = (this.points[i].x + this.points[i + 1].x) / 2;
					const yc = (this.points[i].y + this.points[i + 1].y) / 2;
					this.ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
				}

				this.ctx.stroke();
				this.ctx.restore();
			}
		}

		/**
		 * Draw a dot
		 */
		drawDot(point) {
			this.ctx.save();
			this.ctx.fillStyle = this.options.penColor;
			this.ctx.beginPath();
			this.ctx.arc(
				point.x,
				point.y,
				this.options.dotSize ||
					(this.options.minWidth + this.options.maxWidth) / 4,
				0,
				2 * Math.PI
			);
			this.ctx.fill();
			this.ctx.restore();
		}

		/**
		 * Draw a line between two points
		 */
		drawLine(startPoint, endPoint) {
			const { ctx, options } = this;

			// Only update when there's real movement
			const distance = this.getDistance(startPoint, endPoint);
			if (distance < options.minDistance) return;

			// Cache for performance
			const velocity = this.getVelocity(startPoint, endPoint);
			const width = this.getWidth(velocity);

			// Avoid redundant context changes (set once)
			if (!this._ctxConfigured) {
				ctx.lineCap = "round";
				ctx.lineJoin = "round";
				ctx.strokeStyle = options.penColor;
				this._ctxConfigured = true;
			}

			if (options.smoothing > 0) {
				this.drawSmoothLine(startPoint, endPoint, width);
			} else {
				ctx.beginPath();
				ctx.moveTo(startPoint.x, startPoint.y);
				ctx.lineTo(endPoint.x, endPoint.y);
				ctx.lineWidth = width;
				ctx.stroke();
			}

			this.updateHasContentClass();
		}

		/**
		 * Draw smooth line with quadratic curve smoothing (Catmull–Rom style)
		 */
		drawSmoothLine(startPoint, endPoint, width) {
			const { ctx, points, options } = this;

			if (points.length < 4) {
				// Fast path for initial strokes
				ctx.beginPath();
				ctx.moveTo(startPoint.x, startPoint.y);
				ctx.lineTo(endPoint.x, endPoint.y);
				ctx.lineWidth = width;
				ctx.stroke();
				return;
			}

			ctx.beginPath();
			ctx.lineWidth = width;

			// Optimized Catmull–Rom spline
			const len = points.length - 2;
			let prev = points[0];

			for (let i = 1; i < len; i++) {
				const p = points[i];
				const next = points[i + 1];
				const xc = (p.x + next.x) * 0.5;
				const yc = (p.y + next.y) * 0.5;

				ctx.quadraticCurveTo(p.x, p.y, xc, yc);
				prev = p;
			}

			// Final curve segment
			const last = points.length - 1;
			ctx.quadraticCurveTo(
				points[last - 1].x,
				points[last - 1].y,
				points[last].x,
				points[last].y
			);

			ctx.stroke();
		}

		/**
		 * Calculate distance between two points
		 */
		getDistance(startPoint, endPoint) {
			return Math.sqrt(
				Math.pow(endPoint.x - startPoint.x, 2) +
					Math.pow(endPoint.y - startPoint.y, 2)
			);
		}

		/**
		 * Calculate velocity between two points
		 */
		getVelocity(startPoint, endPoint) {
			const distance = this.getDistance(startPoint, endPoint);
			const time = endPoint.time - startPoint.time;

			return time > 0 ? distance / time : 0;
		}

		/**
		 * Calculate line width based on velocity
		 */
		getWidth(velocity) {
			const minWidth = this.options.minWidth;
			const maxWidth = this.options.maxWidth;
			const velocityWeight = this.options.velocityFilterWeight;

			return Math.max(
				minWidth,
				Math.min(maxWidth, maxWidth - velocity * velocityWeight)
			);
		}

		/**
		 * Clear the signature
		 */
		clear() {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.ctx.fillStyle = this.options.backgroundColor;
			this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

			this.points = [];
			this.lastPoint = null;
			this._isEmpty = true;

			if (this.options.onSignatureChange) {
				this.options.onSignatureChange();
			}
		}

		/**
		 * Check if signature is empty
		 */
		isEmpty() {
			return this._isEmpty || this.points.length < this.options.minPoints;
		}

		/**
		 * Validate signature
		 */
		isValid() {
			if (this.isEmpty()) {
				return false;
			}

			// Check minimum distance
			if (this.points.length < 2) {
				return false;
			}

			const totalDistance = this.calculateTotalDistance();
			return totalDistance >= this.options.minDistance;
		}

		/**
		 * Calculate total distance of signature
		 */
		calculateTotalDistance() {
			let totalDistance = 0;

			for (let i = 1; i < this.points.length; i++) {
				totalDistance += this.getDistance(this.points[i - 1], this.points[i]);
			}

			return totalDistance;
		}

		/**
		 * Get signature as PNG data URL
		 */
		toDataURL(type = "image/png", quality = 1) {
			return this.canvas.toDataURL(type, quality);
		}

		/**
		 * Get signature as SVG
		 */
		toSVG() {
			const rect = this.canvas.getBoundingClientRect();
			const ratio = this.canvas.width / rect.width;

			let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${rect.width}" height="${rect.height}">`;
			svg += `<rect width="100%" height="100%" fill="${this.options.backgroundColor}"/>`;

			if (this.points.length > 0) {
				svg += `<path d="`;

				for (let i = 0; i < this.points.length; i++) {
					const point = this.points[i];
					const command = i === 0 ? "M" : "L";
					svg += `${command}${point.x / ratio},${point.y / ratio} `;
				}

				svg += `" stroke="${this.options.penColor}" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
			}

			svg += `</svg>`;
			return svg;
		}

		/**
		 * Get signature data as JSON
		 */
		toJSON() {
			return {
				points: this.points,
				width: this.canvas.width,
				height: this.canvas.height,
				ratio: this.canvas.width / this.canvas.getBoundingClientRect().width,
				options: this.options,
				timestamp: Date.now(),
			};
		}

		/**
		 * Load signature from JSON data
		 */
		fromJSON(data) {
			if (!data || !data.points) {
				throw new Error("Invalid signature data");
			}

			this.clear();
			this.points = data.points;
			this._isEmpty = false;

			this.redraw();

			if (this.options.onSignatureChange) {
				this.options.onSignatureChange();
			}
		}

		/**
		 * Redraw signature from points
		 */
		redraw() {
			if (this._isEmpty || this.points.length === 0) {
				return;
			}

			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.ctx.fillStyle = this.options.backgroundColor;
			this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

			for (let i = 1; i < this.points.length; i++) {
				this.drawLine(this.points[i - 1], this.points[i]);
			}
		}

		/**
		 * Set pen color
		 */
		setPenColor(color) {
			this.options.penColor = color;
		}

		/**
		 * Set background color
		 */
		setBackgroundColor(color) {
			this.options.backgroundColor = color;
			this.redraw();
		}

		/**
		 * Set line width range
		 */
		setLineWidth(min, max) {
			this.options.minWidth = min;
			this.options.maxWidth = max;
		}

		/**
		 * Utility: Debounce function
		 */
		debounce(func, wait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		}
	}

	/**
	 * Signature Pad Manager for multiple instances
	 */
	class PenTraceManager {
		constructor() {
			this.instances = new Map();
		}

		/**
		 * Create a new signature pad instance
		 */
		create(canvas, options = {}) {
			const id = this.generateId();
			const signaturePad = new PenTrace(canvas, options);

			this.instances.set(id, signaturePad);
			canvas.setAttribute("data-signature-pad-id", id);

			return signaturePad;
		}

		/**
		 * Get signature pad instance by canvas
		 */
		getByCanvas(canvas) {
			const id = canvas.getAttribute("data-signature-pad-id");
			return id ? this.instances.get(id) : null;
		}

		/**
		 * Get signature pad instance by ID
		 */
		getById(id) {
			return this.instances.get(id);
		}

		/**
		 * Remove signature pad instance
		 */
		remove(canvas) {
			const id = canvas.getAttribute("data-signature-pad-id");
			if (id) {
				this.instances.delete(id);
				canvas.removeAttribute("data-signature-pad-id");
			}
		}

		/**
		 * Clear all signature pads
		 */
		clearAll() {
			this.instances.forEach((signaturePad) => {
				signaturePad.clear();
			});
		}

		/**
		 * Generate unique ID
		 */
		generateId() {
			return "pentrace-sig-" + Math.random().toString(36).substr(2, 9);
		}
	}

	/**
	 * Global manager instance
	 */
	const manager = new PenTraceManager();

	/**
	 * Public API
	 */
	const PenTraceAPI = {
		/**
		 * Create signature pad
		 */
		create: function (canvas, options) {
			return manager.create(canvas, options);
		},

		/**
		 * Get signature pad by canvas
		 */
		get: function (canvas) {
			return manager.getByCanvas(canvas);
		},

		/**
		 * Clear all signature pads
		 */
		clearAll: function () {
			manager.clearAll();
		},

		/**
		 * Utility functions
		 */
		utils: {
			/**
			 * Download signature as file
			 */
			downloadSignature: function (
				signaturePad,
				filename = "signature",
				format = "png"
			) {
				let data, mimeType, extension;

				switch (format.toLowerCase()) {
					case "svg":
						data = signaturePad.toSVG();
						mimeType = "image/svg+xml";
						extension = "svg";
						break;
					case "json":
						data = JSON.stringify(signaturePad.toJSON(), null, 2);
						mimeType = "application/json";
						extension = "json";
						break;
					default:
						const tempCanvas = document.createElement("canvas");
						const ctx = tempCanvas.getContext("2d");
						tempCanvas.width = signaturePad.canvas.width;
						tempCanvas.height = signaturePad.canvas.height;

						ctx.drawImage(signaturePad.canvas, 0, 0);

						data = tempCanvas.toDataURL("image/png");
						mimeType = "image/png";
						extension = "png";
				}

				const a = document.createElement("a");
				a.href = data;
				a.download = `${filename}.${extension}`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
			},

			/**
			 * Print signature
			 */
			printSignature: function (signaturePad) {
				const printWindow = window.open("", "_blank");
				const svg = signaturePad.toSVG();

				printWindow.document.write(`
                    <html>
                        <head>
                            <title>Signature</title>
                            <style>
                                body { margin: 0; padding: 20px; text-align: center; }
                                svg { max-width: 100%; height: auto; border: 1px solid #ccc; }
                            </style>
                        </head>
                        <body>
                            ${svg}
                        </body>
                    </html>
                `);

				printWindow.document.close();
				printWindow.print();
			},

			/**
			 * Validate all signature pads on page
			 */
			validateAll: function () {
				const results = [];
				manager.instances.forEach((signaturePad, id) => {
					results.push({
						id: id,
						isValid: signaturePad.isValid(),
						isEmpty: signaturePad.isEmpty(),
					});
				});
				return results;
			},
		},
	};

	// Export to global scope
	if (typeof module !== "undefined" && module.exports) {
		module.exports = PenTraceAPI;
	} else {
		global.PenTrace = PenTraceAPI;
	}
})(typeof window !== "undefined" ? window : this);
